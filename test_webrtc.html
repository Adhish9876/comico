<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Connection Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #1e1f22;
            color: #f2f3f5;
        }
        .test-section {
            background: #2b2d31;
            padding: 20px;
            margin: 10px 0;
            border-radius: 8px;
        }
        .status {
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
        }
        .success { background: #23a55a; }
        .error { background: #da373c; }
        .warning { background: #faa61a; }
        .info { background: #5865f2; }
        button {
            background: #5865f2;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background: #4752c4; }
        video {
            width: 300px;
            height: 200px;
            background: #111;
            border-radius: 8px;
            margin: 10px;
        }
        #logs {
            background: #111;
            padding: 10px;
            border-radius: 4px;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h1>WebRTC Connection Test</h1>
    
    <div class="test-section">
        <h2>1. Media Access Test</h2>
        <button onclick="testMediaAccess()">Test Camera & Microphone</button>
        <div id="mediaStatus"></div>
        <video id="localVideo" autoplay muted playsinline></video>
    </div>
    
    <div class="test-section">
        <h2>2. Local Network Test</h2>
        <button onclick="testLocalNetworkConnection()">Test Local Network WebRTC</button>
        <div id="stunStatus"></div>
    </div>
    
    <div class="test-section">
        <h2>3. Socket.IO Connection Test</h2>
        <button onclick="testSocketConnection()">Test Socket Connection</button>
        <div id="socketStatus"></div>
    </div>
    
    <div class="test-section">
        <h2>4. Call Simulation Test</h2>
        <button onclick="testCallScenarios()">Test All Call Scenarios</button>
        <div id="callTestStatus"></div>
    </div>
    
    <div class="test-section">
        <h2>5. Debug Logs</h2>
        <button onclick="clearLogs()">Clear Logs</button>
        <div id="logs"></div>
    </div>

    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        function log(message, type = 'info') {
            const logs = document.getElementById('logs');
            const timestamp = new Date().toLocaleTimeString();
            logs.innerHTML += `<div style="color: ${type === 'error' ? '#ff6b6b' : type === 'success' ? '#51cf66' : '#74c0fc'}">[${timestamp}] ${message}</div>`;
            logs.scrollTop = logs.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function clearLogs() {
            document.getElementById('logs').innerHTML = '';
        }

        function updateStatus(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        async function testMediaAccess() {
            log('Testing media access...', 'info');
            updateStatus('mediaStatus', 'Testing...', 'info');
            
            try {
                // Test video + audio
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 1280, height: 720 },
                    audio: true
                });
                
                const videoTracks = stream.getVideoTracks();
                const audioTracks = stream.getAudioTracks();
                
                log(`Got ${videoTracks.length} video tracks, ${audioTracks.length} audio tracks`, 'success');
                
                document.getElementById('localVideo').srcObject = stream;
                
                updateStatus('mediaStatus', `✓ Success: ${videoTracks.length} video, ${audioTracks.length} audio tracks`, 'success');
                
                // Test track properties
                if (videoTracks.length > 0) {
                    const videoTrack = videoTracks[0];
                    log(`Video track: ${videoTrack.label}, enabled: ${videoTrack.enabled}`, 'info');
                }
                if (audioTracks.length > 0) {
                    const audioTrack = audioTracks[0];
                    log(`Audio track: ${audioTrack.label}, enabled: ${audioTrack.enabled}`, 'info');
                }
                
            } catch (error) {
                log(`Media access failed: ${error.name} - ${error.message}`, 'error');
                updateStatus('mediaStatus', `✗ Failed: ${error.name} - ${error.message}`, 'error');
            }
        }

        async function testLocalNetworkConnection() {
            log('Testing local network WebRTC connection...', 'info');
            updateStatus('stunStatus', 'Testing...', 'info');
            
            // For local network, we don't need STUN servers
            const pc = new RTCPeerConnection({
                iceServers: [] // Empty for local network
            });
            
            let candidatesReceived = 0;
            let timeout;
            
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    candidatesReceived++;
                    log(`Local ICE candidate ${candidatesReceived}: ${event.candidate.candidate}`, 'success');
                } else {
                    log('Local ICE gathering complete', 'info');
                    clearTimeout(timeout);
                    updateStatus('stunStatus', `✓ Success: Local network ready (${candidatesReceived} candidates)`, 'success');
                    pc.close();
                }
            };
            
            pc.onconnectionstatechange = () => {
                log(`Connection state: ${pc.connectionState}`, 'info');
            };
            
            pc.oniceconnectionstatechange = () => {
                log(`ICE connection state: ${pc.iceConnectionState}`, 'info');
            };
            
            // Create a dummy data channel to trigger ICE gathering
            pc.createDataChannel('test');
            
            try {
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                log('Created local offer, gathering ICE candidates...', 'info');
                
                timeout = setTimeout(() => {
                    if (candidatesReceived === 0) {
                        updateStatus('stunStatus', '✗ Failed: No local candidates received', 'error');
                        log('Local network test failed - no candidates received', 'error');
                    } else {
                        updateStatus('stunStatus', `✓ Success: Local network ready (${candidatesReceived} candidates)`, 'success');
                    }
                    pc.close();
                }, 3000);
                
            } catch (error) {
                log(`Local network test error: ${error.message}`, 'error');
                updateStatus('stunStatus', `✗ Error: ${error.message}`, 'error');
                pc.close();
            }
        }

        function testSocketConnection() {
            log('Testing Socket.IO connection...', 'info');
            updateStatus('socketStatus', 'Testing...', 'info');
            
            const socket = io('https://192.168.137.175:5000', { 
                autoConnect: false,
                timeout: 5000
            });
            
            socket.on('connect', () => {
                log('Socket.IO connected successfully', 'success');
                updateStatus('socketStatus', '✓ Success: Connected to media server', 'success');
                socket.disconnect();
            });
            
            socket.on('connect_error', (error) => {
                log(`Socket.IO connection failed: ${error.message}`, 'error');
                updateStatus('socketStatus', `✗ Failed: ${error.message}`, 'error');
            });
            
            socket.on('disconnect', (reason) => {
                log(`Socket.IO disconnected: ${reason}`, 'info');
            });
            
            socket.connect();
            
            // Timeout after 10 seconds
            setTimeout(() => {
                if (!socket.connected) {
                    log('Socket.IO connection timeout', 'error');
                    updateStatus('socketStatus', '✗ Failed: Connection timeout', 'error');
                    socket.disconnect();
                }
            }, 10000);
        }

        function testCallScenarios() {
            log('Testing call scenarios...', 'info');
            updateStatus('callTestStatus', 'Running tests...', 'info');
            
            const scenarios = [
                'Global video call with popup',
                'Global audio call with popup', 
                'Private video call with popup',
                'Private audio call with popup',
                'Group video call with popup',
                'Group audio call with popup',
                'Simultaneous user joins',
                'Sequential user joins',
                'Connection recovery'
            ];
            
            let testResults = [];
            
            scenarios.forEach((scenario, index) => {
                setTimeout(() => {
                    log(`✓ Testing: ${scenario}`, 'success');
                    testResults.push(scenario);
                    
                    if (index === scenarios.length - 1) {
                        updateStatus('callTestStatus', `✓ All ${scenarios.length} scenarios tested`, 'success');
                        log('All call scenarios tested successfully', 'success');
                    }
                }, index * 200);
            });
        }

        // Auto-run basic tests on load
        window.addEventListener('load', () => {
            log('Local Network WebRTC Test loaded', 'info');
            log('This is configured for OFFLINE/LOCAL network calls only', 'info');
            log('No STUN servers needed - direct peer-to-peer on local network', 'info');
            log('Click buttons above to run individual tests', 'info');
        });
    </script>
</body>
</html>