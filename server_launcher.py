#!/usr/bin/env python3
"""
server_launcher.py - Unified Shadow Nexus Server Launcher
Manages environment variables and starts all server components in a single executable

This launcher:
1. Detects the server's LAN IP automatically
2. Creates/updates .env file with SERVER_IP
3. Starts server.py (chat server)
4. Starts video_module.py (video/WebRTC server)
5. Handles graceful shutdown
"""

import subprocess
import sys
import os
import signal
import socket
import time
import threading
from pathlib import Path
from typing import Optional
import warnings
import traceback

warnings.filterwarnings('ignore')

def safe_print(text):
    """Print text safely, handling Unicode encoding issues in Windows console"""
    try:
        print(text)
    except UnicodeEncodeError:
        # Replace problematic Unicode characters with ASCII equivalents
        safe_text = (text
                    .replace('ðŸš€', '[*]')
                    .replace('ðŸ“‚', '[DIR]')
                    .replace('âœ…', '[OK]')
                    .replace('ðŸ“¡', '[CHAT]')
                    .replace('ðŸ“¹', '[VIDEO]')
                    .replace('ðŸŒ', '[NET]')
                    .replace('ðŸ“', '[FILE]')
                    .replace('ðŸ”Š', '[AUDIO]')
                    .replace('ðŸ’¡', '[INFO]')
                    .replace('â¹ï¸', '[STOP]')
                    .replace('âŒ', '[ERROR]'))
        print(safe_text)


# Small file logger to capture early-start crashes from the frozen exe
LOG_PATH = os.path.join(os.path.dirname(__file__), 'server_launcher.log') if '__file__' in globals() else os.path.join(os.getcwd(), 'server_launcher.log')
def log_to_file(msg: str):
    try:
        with open(LOG_PATH, 'a', encoding='utf-8', errors='replace') as lf:
            lf.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} - {msg}\n")
    except Exception:
        # Best-effort logging only
        pass

# Write initial startup marker
log_to_file('=== server_launcher.py startup ===')

class ServerLauncher:
    """Manages server processes and environment"""
    
    def __init__(self):
        self.base_dir = self._get_base_dir()
        self.env_file = os.path.join(self.base_dir, '.env')
        self.processes = []
        self.running = True
        
        # Set up signal handlers for graceful shutdown
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)
        
    def _get_base_dir(self) -> str:
        """Get the base directory (works in both script and exe modes)"""
        if getattr(sys, 'frozen', False):
            # Running as compiled executable
            return os.path.dirname(sys.executable)
        else:
            # Running as script
            return os.path.dirname(os.path.abspath(__file__))
    
    def _signal_handler(self, sig, frame):
        """Handle Ctrl+C gracefully"""
        safe_print("\n\n[STOP] Shutting down servers...")
        self.shutdown()
        sys.exit(0)
    
    def get_lan_ip(self) -> str:
        """Detect the LAN IP address of this machine"""
        try:
            # Connect to an external address (doesn't need to be reachable)
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))  # Google DNS
            ip = s.getsockname()[0]
            s.close()
            return ip
        except Exception as e:
            print(f"[WARN] Could not detect LAN IP: {e}")
            print("Using localhost as fallback")
            return "127.0.0.1"
    
    def setup_env(self, server_ip: Optional[str] = None) -> str:
        """
        Setup .env file with SERVER_IP
        
        Args:
            server_ip: IP to use. If None, will be auto-detected
            
        Returns:
            The SERVER_IP being used
        """
        if server_ip is None:
            server_ip = self.get_lan_ip()
        
        # Check if .env exists
        if os.path.exists(self.env_file):
            print(f"[ENV] .env file found at: {self.env_file}")
            # Read existing value
            try:
                with open(self.env_file, 'r') as f:
                    content = f.read()
                    if 'SERVER_IP=' in content:
                        existing_ip = content.split('SERVER_IP=')[1].split('\n')[0].strip()
                        print(f"   Current SERVER_IP: {existing_ip}")
                        return existing_ip
            except Exception as e:
                print(f"   [WARN] Could not read .env: {e}")
        
        # Create or update .env
        env_content = f"""# Shadow Nexus Server Configuration
# Auto-generated by server_launcher.py

SERVER_IP={server_ip}

"""
        
        try:
            with open(self.env_file, 'w') as f:
                f.write(env_content)
            safe_print(f"[OK] .env created/updated with SERVER_IP: {server_ip}")
            return server_ip
        except Exception as e:
            safe_print(f"[ERROR] Error writing .env: {e}")
            return server_ip
    
    def start_chat_server(self, env: dict):
        """Start the chat server (server.py)"""
        safe_print("\n[CHAT] Starting Chat Server...")
        print("=" * 60)
        
        try:
            process = subprocess.Popen(
                [sys.executable, '-W', 'ignore', 'server.py'],
                cwd=self.base_dir,
                env=env,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                text=True,
                encoding='utf-8',
                errors='replace'
            )
            
            self.processes.append(('Chat', process))
            print("[CHAT] Chat server started (PID: {})".format(process.pid))
            
            # Wait for process with periodic checks instead of blocking indefinitely
            while process.poll() is None:
                time.sleep(1)
                    
        except Exception as e:
            log_to_file(f"Error starting chat server: {e}")
            print(f"[ERROR] Error starting chat server: {e}")
    
    def start_video_server(self, env: dict):
        """Start the video server (video_module.py)"""
        safe_print("\n[VIDEO] Starting Video Server...")
        print("=" * 60)
        
        try:
            process = subprocess.Popen(
                [sys.executable, '-W', 'ignore', 'video_module.py'],
                cwd=self.base_dir,
                env=env,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                text=True,
                encoding='utf-8',
                errors='replace'
            )
            
            self.processes.append(('Video', process))
            print("[VIDEO] Video server started (PID: {})".format(process.pid))
            
            # Wait for process with periodic checks instead of blocking indefinitely
            while process.poll() is None:
                time.sleep(1)
                    
        except Exception as e:
            log_to_file(f"Error starting video server: {e}")
            print(f"[ERROR] Error starting video server: {e}")
    
    def run(self, server_ip: Optional[str] = None):
        """
        Run all servers
        
        Args:
            server_ip: Optional IP to use instead of auto-detecting
        """
        print("\n" + "=" * 60)
        safe_print("[*] Shadow Nexus - Unified Server Launcher")
        print("=" * 60)
        safe_print(f"[DIR] Server directory: {self.base_dir}")
        
        # Setup environment
        server_ip = self.setup_env(server_ip)
        
        # Prepare environment variables for subprocesses
        env = os.environ.copy()
        env['PYTHONWARNINGS'] = 'ignore'
        env['SERVER_IP'] = server_ip
        env['PYTHONIOENCODING'] = 'utf-8'  # Fix Unicode encoding in subprocesses
        
        # Start both servers in separate threads
        chat_thread = threading.Thread(
            target=self.start_chat_server,
            args=(env,),
            daemon=False  # Changed to False so program waits for threads
        )
        video_thread = threading.Thread(
            target=self.start_video_server,
            args=(env,),
            daemon=False  # Changed to False so program waits for threads
        )
        
        chat_thread.start()
        time.sleep(2)  # Give chat server time to start
        video_thread.start()
        
        # Print connection info
        print("\n" + "=" * 60)
        safe_print("[OK] All Servers Started!")
        print("=" * 60)
        safe_print(f"\n[NET] Server IP Address: {server_ip}")
        safe_print(f"[CHAT] Chat Server: {server_ip}:5555")
        safe_print(f"[FILE] File Server: {server_ip}:5556")
        safe_print(f"[AUDIO] Audio Server: {server_ip}:5557")
        safe_print(f"[VIDEO] Video Server: {server_ip}:5000")
        safe_print(f"\n[OK] Clients can connect to: {server_ip}")
        safe_print("\n[INFO] Press Ctrl+C to shut down all servers")
        print("=" * 60 + "\n")
        
        # Keep the program running and wait for Ctrl+C with timeout
        try:
            while self.running:
                # Use small timeout so we don't block indefinitely
                # This allows KeyboardInterrupt to be caught responsively
                time.sleep(0.5)
        except KeyboardInterrupt:
            self.shutdown()
    
    def shutdown(self):
        """Gracefully shutdown all server processes"""
        print("\n[STOP] Stopping all server processes...")
        
        for name, process in self.processes:
            try:
                print(f"   Stopping {name} server...")
                process.terminate()
                try:
                    process.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    print(f"   Force killing {name} server...")
                    process.kill()
                    process.wait()
                safe_print(f"   [OK] {name} server stopped")
            except Exception as e:
                print(f"   [WARN] Error stopping {name} server: {e}")
        
        self.running = False
        safe_print("\n[OK] All servers shutdown complete")


def main():
    """Main entry point"""
    try:
        log_to_file('main() called')
        launcher = ServerLauncher()
        log_to_file('ServerLauncher created')
        
        # You can pass custom IP as argument: python server_launcher.py 192.168.1.100
        server_ip = sys.argv[1] if len(sys.argv) > 1 else None
        log_to_file(f'Starting with server_ip={server_ip}')
        
        launcher.run(server_ip)
        log_to_file('launcher.run() completed')
    except KeyboardInterrupt:
        log_to_file('KeyboardInterrupt received')
        try:
            launcher.shutdown()
        except Exception:
            pass
    except Exception as e:
        # Log exception to file for post-mortem when running as an exe
        try:
            log_to_file(f"Fatal error in main: {e}")
            log_to_file(traceback.format_exc())
        except Exception:
            pass
        # Also print to console if available
        try:
            print(f"\n[ERROR] Fatal error: {e}")
            print(traceback.format_exc())
        except Exception:
            pass
        try:
            launcher.shutdown()
        except Exception:
            pass
        sys.exit(1)


if __name__ == '__main__':
    main()
