<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow Nexus - Audio Call</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Bangers&family=Comic+Neue:wght@400;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Neue', cursive;
            background: linear-gradient(135deg, #1a1d29 0%, #252936 100%);
            color: #f2f3f5;
            overflow: hidden;
        }

        .audio-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .header {
            background: #2b2d31;
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #00b8d4;
            z-index: 100;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .session-info h2 {
            font-size: 18px;
            font-weight: 700;
            color: #00b8d4;
            margin-bottom: 2px;
            letter-spacing: 0.5px;
            font-family: 'Bangers', cursive;
        }

        .session-info p {
            font-size: 12px;
            color: #949ba4;
            font-weight: 500;
        }

        .participants-grid {
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 40px;
            overflow-y: auto;
        }

        .participant-card {
            width: 200px;
            height: 200px;
            background: linear-gradient(135deg, #2d3142 0%, #252936 100%);
            border-radius: 16px;
            border: 3px solid #4a5568;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            animation: slideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .participant-card.speaking {
            border-color: #00b8d4;
            box-shadow: 0 0 20px rgba(0, 184, 212, 0.5);
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { 
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4), 0 0 20px rgba(0, 184, 212, 0.5);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4), 0 0 30px rgba(0, 184, 212, 0.8);
                transform: scale(1.05);
            }
        }

        .participant-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00b8d4 0%, #9c27b0 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            font-weight: 900;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            margin-bottom: 16px;
            font-family: 'Bangers', cursive;
            letter-spacing: 2px;
        }

        .participant-name {
            font-size: 16px;
            font-weight: 700;
            color: #f2f3f5;
            text-align: center;
            margin-bottom: 8px;
        }

        .participant-status {
            font-size: 12px;
            color: #949ba4;
            text-align: center;
        }

        .muted-indicator {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background: rgba(220, 53, 69, 0.9);
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .muted-indicator.active {
            display: flex;
        }

        .hand-raised-indicator {
            position: absolute;
            top: 8px;
            left: 8px;
            background: rgba(250, 166, 26, 0.95);
            color: #fff;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            display: none;
            align-items: center;
            gap: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .hand-raised-indicator.active {
            display: flex;
        }

        .controls {
            background: #2b2d31;
            padding: 16px;
            display: flex;
            justify-content: center;
            gap: 12px;
            border-top: 1px solid #1e1f22;
            z-index: 100;
            box-shadow: 0 -1px 0 rgba(4,4,5,0.2);
        }

        .control-btn {
            width: 44px;
            height: 44px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 20px;
            background: #3c3f45;
            position: relative;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .control-btn:hover {
            background: #4e5058;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .control-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .control-btn svg {
            width: 22px;
            height: 22px;
            fill: #f2f3f5;
            stroke: none;
            transition: all 0.2s ease;
        }

        .control-btn:hover svg {
            filter: drop-shadow(0 0 4px rgba(255, 255, 255, 0.5));
        }

        .control-btn::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-8px);
            background: #111214;
            color: #f2f3f5;
            padding: 6px 10px;
            border-radius: 5px;
            font-size: 13px;
            font-weight: 600;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.17s;
            box-shadow: 0 8px 16px rgba(0,0,0,0.4);
        }

        .control-btn:hover::after {
            opacity: 1;
        }

        .mic-btn.muted {
            background: #da373c;
        }

        .mic-btn.muted:hover {
            background: #a12d30;
        }

        .hand-btn {
            background: #3c3f45;
        }

        .hand-btn.raised {
            background: #faa61a;
        }

        .hand-btn.raised:hover {
            background: #f0a020;
        }

        .leave-btn {
            background: #da373c;
        }

        .leave-btn:hover {
            background: #a12d30;
        }

        .participants-panel {
            position: absolute;
            top: 60px;
            right: 16px;
            background: #2b2d31;
            padding: 12px;
            border-radius: 8px;
            min-width: 220px;
            border: 1px solid #1e1f22;
            z-index: 1001;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: 0 8px 16px rgba(0,0,0,0.4);
            animation: slideInRight 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .participants-panel h3 {
            font-size: 12px;
            font-weight: 700;
            color: #949ba4;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .participant-list {
            list-style: none;
        }

        .participant-list li {
            padding: 6px 8px;
            font-size: 14px;
            color: #f2f3f5;
            font-weight: 500;
            border-radius: 4px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            animation: fadeInLeft 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes fadeInLeft {
            from {
                opacity: 0;
                transform: translateX(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .participant-list li:hover {
            background: #3c3f45;
            transform: translateX(4px);
        }

        .participant-list li::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #23a55a;
            box-shadow: 0 0 4px rgba(35, 165, 90, 0.5);
            flex-shrink: 0;
        }

        .participant-list li.hand-raised {
            background: rgba(250, 166, 26, 0.1);
            border-left: 3px solid #faa61a;
            padding-left: 5px;
        }

        .participant-list li .hand-icon {
            margin-left: auto;
            font-size: 16px;
            animation: wave 0.5s ease-in-out infinite;
        }

        @keyframes wave {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(15deg); }
            75% { transform: rotate(-15deg); }
        }

        .connecting-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1d29;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            animation: fadeOut 0.5s cubic-bezier(0.4, 0, 0.2, 1) 1s forwards;
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
                pointer-events: none;
            }
        }

        .spinner {
            width: 48px;
            height: 48px;
            border: 4px solid #2b2d31;
            border-top-color: #00b8d4;
            border-radius: 50%;
            animation: spin 0.8s linear infinite, spinPulse 2s ease-in-out infinite;
            margin-bottom: 16px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes spinPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(0, 184, 212, 0.7); }
            50% { box-shadow: 0 0 0 10px rgba(0, 184, 212, 0); }
        }

        .connecting-text {
            font-size: 16px;
            font-weight: 600;
            color: #949ba4;
        }

        .notification-toast {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(-20px);
            background: #2b2d31;
            color: #f2f3f5;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            box-shadow: 0 8px 16px rgba(0,0,0,0.4);
            border: 1px solid #1e1f22;
            opacity: 0;
            pointer-events: none;
            z-index: 2001;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .notification-toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
            animation: slideDown 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes slideDown {
            from {
                transform: translateX(-50%) translateY(-20px);
            }
            to {
                transform: translateX(-50%) translateY(0);
            }
        }

        .reactions-menu {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%) scale(0.8);
            background: #2b2d31;
            padding: 8px;
            border-radius: 24px;
            display: none;
            gap: 4px;
            border: 1px solid #1e1f22;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
            z-index: 1002;
            opacity: 0;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .reactions-menu.active {
            display: flex;
            opacity: 1;
            transform: translateX(-50%) scale(1);
            animation: popUp 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes popUp {
            from {
                opacity: 0;
                transform: translateX(-50%) scale(0.8) translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) scale(1) translateY(0);
            }
        }

        .reaction-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background: #3c3f45;
            cursor: pointer;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            animation: popIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes popIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .reaction-btn:hover {
            background: #4e5058;
            transform: scale(1.2);
        }

        .reaction-btn:active {
            transform: scale(1.1);
        }

        .reaction-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 80px;
            z-index: 15;
            pointer-events: none;
            animation: reactionPop 1.5s ease-out forwards;
        }

        @keyframes reactionPop {
            0% { 
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            20% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -80%) scale(1);
            }
        }

        /* Color palette for participant avatars */
        .participant-avatar.color-1 { background: linear-gradient(135deg, #00b8d4 0%, #9c27b0 100%); }
        .participant-avatar.color-2 { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        .participant-avatar.color-3 { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
        .participant-avatar.color-4 { background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); }
        .participant-avatar.color-5 { background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); }
        .participant-avatar.color-6 { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .participant-avatar.color-7 { background: linear-gradient(135deg, #ff9a56 0%, #ff6a88 100%); }
        .participant-avatar.color-8 { background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); }
        .participant-avatar.color-9 { background: linear-gradient(135deg, #ffa400 0%, #ff6b6b 100%); }
        .participant-avatar.color-10 { background: linear-gradient(135deg, #1fa2ff 0%, #12d8fa 100%); }
        .participant-avatar.color-11 { background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%); }
        .participant-avatar.color-12 { background: linear-gradient(135deg, #30cfd0 0%, #330867 100%); }

        /* Custom scrollbar for participants panel */
        .participants-panel::-webkit-scrollbar {
            width: 8px;
        }

        .participants-panel::-webkit-scrollbar-track {
            background: #1e1f22;
            border-radius: 4px;
        }

        .participants-panel::-webkit-scrollbar-thumb {
            background: #3c3f45;
            border-radius: 4px;
        }

        .participants-panel::-webkit-scrollbar-thumb:hover {
            background: #4e5058;
        }
    </style>
</head>
<body>
    <div class="audio-container">
        <div class="header">
            <div class="session-info">
                <h2>{{ session_name }}</h2>
                <p>Session ID: {{ session_id }}</p>
            </div>
        </div>

        <div class="participants-grid" id="participantsGrid">
            <!-- Participants will be added here dynamically -->
        </div>

        <div class="controls">
            <button class="control-btn mic-btn" id="micBtn" data-tooltip="Mute">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
                    <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
                    <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
                </svg>
            </button>
            <button class="control-btn hand-btn" id="handBtn" data-tooltip="Raise Hand">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
                    <path d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>
                </svg>
            </button>
            <button class="control-btn" id="reactionBtn" data-tooltip="Send Reaction">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5zm-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11zm3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5z"/>
                </svg>
            </button>
            <button class="control-btn leave-btn" id="leaveBtn" data-tooltip="Leave Call">
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
                    <path d="M12 9c-1.6 0-3.15.25-4.6.72v3.1c0 .39-.23.74-.56.9-.98.49-1.87 1.12-2.66 1.85-.18.18-.43.28-.7.28-.28 0-.53-.11-.71-.29L.29 13.08c-.18-.17-.29-.42-.29-.7 0-.28.11-.53.29-.71C3.34 8.78 7.46 7 12 7s8.66 1.78 11.71 4.67c.18.18.29.43.29.71 0 .28-.11.53-.29.7l-2.48 2.48c-.18.18-.43.29-.71.29-.27 0-.52-.1-.7-.28-.79-.73-1.68-1.36-2.66-1.85-.33-.16-.56-.51-.56-.9v-3.1C15.15 9.25 13.6 9 12 9z"/>
                </svg>
            </button>
        </div>

        <div class="reactions-menu" id="reactionsMenu">
            <button class="reaction-btn" data-reaction="üëç">üëç</button>
            <button class="reaction-btn" data-reaction="‚ù§Ô∏è">‚ù§Ô∏è</button>
            <button class="reaction-btn" data-reaction="üòÇ">üòÇ</button>
            <button class="reaction-btn" data-reaction="üòÆ">üòÆ</button>
            <button class="reaction-btn" data-reaction="üò¢">üò¢</button>
            <button class="reaction-btn" data-reaction="üëè">üëè</button>
            <button class="reaction-btn" data-reaction="üéâ">üéâ</button>
        </div>

        <div class="participants-panel" id="participantsPanel" style="display: none;">
            <h3>Participants ‚Äî <span id="participantCount">1</span></h3>
            <ul class="participant-list" id="participantList">
                <li>You</li>
            </ul>
        </div>

        <div class="notification-toast" id="notificationToast"></div>

        <div class="connecting-overlay" id="connectingOverlay">
            <div class="spinner"></div>
            <div class="connecting-text">Connecting to audio...</div>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        const sessionId = "{{ session_id }}";
        const sessionType = "{{ session_type }}";
        const urlParams = new URLSearchParams(window.location.search);
        const username = urlParams.get('username') || 'Guest';
        const socket = io('https://localhost:5000', { autoConnect: false });
        
        let localStream = null;
        let _peer_list = {};
        let _peer_names = {};
        let myID = null;
        let isMicMuted = false;
        let isHandRaised = false;
        let audioContext = null;
        let audioAnalyser = null;

        const participantsGrid = document.getElementById('participantsGrid');
        const micBtn = document.getElementById('micBtn');
        const handBtn = document.getElementById('handBtn');
        const leaveBtn = document.getElementById('leaveBtn');
        const participantsPanel = document.getElementById('participantsPanel');
        const participantList = document.getElementById('participantList');
        const participantCount = document.getElementById('participantCount');
        const notificationToast = document.getElementById('notificationToast');
        const connectingOverlay = document.getElementById('connectingOverlay');

        const PC_CONFIG = {
            iceServers: [
                {
                    urls: ['stun:stun.l.google.com:19302', 
                           'stun:stun1.l.google.com:19302',
                           'stun:stun2.l.google.com:19302']
                }
            ]
        };

        async function initAudioCall() {
            try {
                // Get audio only
                localStream = await navigator.mediaDevices.getUserMedia({
                    audio: true
                });
                console.log('[AUDIO] Got audio stream');
                
                // Initialize audio level detection
                initAudioLevelDetection();
                
                socket.connect();
                socket.emit('join_session', { session_id: sessionId, username: username });
                
                setTimeout(() => {
                    connectingOverlay.style.display = 'none';
                }, 1000);
                
            } catch (error) {
                console.error('[AUDIO] Error in initAudioCall:', error);
                alert('Error accessing microphone: ' + error.message);
            }
        }

        function createPeerConnection(peer_id) {
            console.log(`Creating peer connection for ${peer_id}`);
            _peer_list[peer_id] = new RTCPeerConnection(PC_CONFIG);

            _peer_list[peer_id].onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('data', {
                        sender_id: myID,
                        target_id: peer_id,
                        type: 'new-ice-candidate',
                        candidate: event.candidate
                    });
                }
            };

            _peer_list[peer_id].ontrack = (event) => {
                console.log(`Audio track received from ${peer_id}`);
                const stream = (event.streams && event.streams[0]) ? event.streams[0] : new MediaStream([event.track]);
                addRemoteParticipant(peer_id, stream);
            };

            _peer_list[peer_id].onnegotiationneeded = () => {
                handleNegotiationNeededEvent(peer_id);
            };

            _peer_list[peer_id].onconnectionstatechange = () => {
                console.log(`PC ${peer_id} state:`, _peer_list[peer_id].connectionState);
                if (_peer_list[peer_id].connectionState === 'failed' || 
                    _peer_list[peer_id].connectionState === 'disconnected') {
                    closeConnection(peer_id);
                }
            };

            return _peer_list[peer_id];
        }

        function addLocalTracks(peer_id) {
            if (localStream && _peer_list[peer_id]) {
                localStream.getTracks().forEach((track) => {
                    _peer_list[peer_id].addTrack(track, localStream);
                });
            }
        }

        async function handleNegotiationNeededEvent(peer_id) {
            try {
                console.log(`Creating offer for ${peer_id}`);
                const offer = await _peer_list[peer_id].createOffer();
                await _peer_list[peer_id].setLocalDescription(offer);
                
                socket.emit('data', {
                    sender_id: myID,
                    target_id: peer_id,
                    type: 'offer',
                    sdp: _peer_list[peer_id].localDescription
                });
            } catch (e) {
                console.error('Error in negotiation:', e);
            }
        }

        async function handleOfferMsg(msg) {
            const peer_id = msg['sender_id'];
            console.log(`Offer received from ${peer_id}`);
            
            if (!_peer_list[peer_id]) {
                createPeerConnection(peer_id);
                addLocalTracks(peer_id);
            }
            
            try {
                const desc = new RTCSessionDescription(msg['sdp']);
                await _peer_list[peer_id].setRemoteDescription(desc);
                
                const answer = await _peer_list[peer_id].createAnswer();
                await _peer_list[peer_id].setLocalDescription(answer);
                
                socket.emit('data', {
                    sender_id: myID,
                    target_id: peer_id,
                    type: 'answer',
                    sdp: _peer_list[peer_id].localDescription
                });
            } catch (e) {
                console.error('Error handling offer:', e);
            }
        }

        async function handleAnswerMsg(msg) {
            const peer_id = msg['sender_id'];
            console.log(`Answer received from ${peer_id}`);
            
            try {
                const desc = new RTCSessionDescription(msg['sdp']);
                await _peer_list[peer_id].setRemoteDescription(desc);
            } catch (e) {
                console.error('Error handling answer:', e);
            }
        }

        async function handleNewICECandidateMsg(msg) {
            const peer_id = msg['sender_id'];
            
            try {
                const candidate = new RTCIceCandidate(msg.candidate);
                await _peer_list[peer_id].addIceCandidate(candidate);
            } catch (e) {
                console.error('Error adding ICE candidate:', e);
            }
        }

        function closeConnection(peer_id) {
            console.log(`Closing connection with ${peer_id}`);
            if (peer_id in _peer_list) {
                _peer_list[peer_id].onicecandidate = null;
                _peer_list[peer_id].ontrack = null;
                _peer_list[peer_id].onnegotiationneeded = null;
                _peer_list[peer_id].close();
                delete _peer_list[peer_id];
            }
            removeRemoteParticipant(peer_id);
        }

        function addRemoteParticipant(peer_id, stream) {
            console.log('[AUDIO] Adding remote participant:', peer_id);
            
            let participantCard = document.getElementById(`participant-${peer_id}`);
            if (!participantCard) {
                participantCard = document.createElement('div');
                participantCard.className = 'participant-card';
                participantCard.id = `participant-${peer_id}`;
                
                const displayName = _peer_names[peer_id] || peer_id;
                const firstLetter = displayName.charAt(0).toUpperCase();
                const colorClass = getAvatarColor(peer_id);
                
                participantCard.innerHTML = `
                    <div class="participant-avatar ${colorClass}">${firstLetter}</div>
                    <div class="participant-name">${displayName}</div>
                    <div class="participant-status">Connected</div>
                    <div class="muted-indicator">üîá</div>
                    <div class="hand-raised-indicator">‚úã Hand Raised</div>
                `;
                
                // Create hidden audio element for this participant
                const audio = document.createElement('audio');
                audio.autoplay = true;
                audio.srcObject = stream;
                audio.style.display = 'none';
                participantCard.appendChild(audio);
                
                participantsGrid.appendChild(participantCard);
            }
            
            updateParticipantCount();
        }

        function removeRemoteParticipant(peer_id) {
            const participantCard = document.getElementById(`participant-${peer_id}`);
            if (participantCard) {
                participantCard.remove();
                delete _peer_names[peer_id];
                updateParticipantCount();
            }
        }

        function getAvatarColor(peer_id) {
            // Use peer_id hash to consistently assign same color to same user
            let hash = 0;
            for (let i = 0; i < peer_id.length; i++) {
                const char = peer_id.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            const colorIndex = (Math.abs(hash) % 12) + 1;
            return `color-${colorIndex}`;
        }

        function showNotification(message) {
            notificationToast.textContent = message;
            notificationToast.classList.add('show');
            setTimeout(() => {
                notificationToast.classList.remove('show');
            }, 3000);
        }

        function showReaction(peer_id, emoji) {
            const participantCard = peer_id === myID ? 
                document.getElementById('participant-local') : 
                document.getElementById(`participant-${peer_id}`);
            
            if (!participantCard) return;

            const reaction = document.createElement('div');
            reaction.className = 'reaction-overlay';
            reaction.textContent = emoji;
            participantCard.appendChild(reaction);

            setTimeout(() => reaction.remove(), 1500);
        }

        function sendReaction(emoji) {
            showReaction(myID, emoji);
            socket.emit('reaction', {
                session_id: sessionId,
                user_id: myID,
                emoji: emoji
            });
            reactionsMenu.classList.remove('active');
        }

        function toggleHandRaise() {
            isHandRaised = !isHandRaised;
            handBtn.classList.toggle('raised', isHandRaised);
            
            // Update local participant card
            const localCard = document.getElementById('participant-local');
            if (localCard) {
                const handIndicator = localCard.querySelector('.hand-raised-indicator');
                handIndicator.classList.toggle('active', isHandRaised);
            }
            
            updateParticipantListWithHands();
        }

        function updateParticipantCount() {
            const totalParticipants = Object.keys(_peer_list).length + 1; // +1 for local user
            participantCount.textContent = totalParticipants;
        }

        function updateParticipantList() {
            participantList.innerHTML = `<li>${username} (You)</li>`;
            Object.keys(_peer_list).forEach(peer_id => {
                const li = document.createElement('li');
                const displayName = _peer_names[peer_id] || 'Loading...';
                li.textContent = displayName;
                li.id = `participant-${peer_id}`;
                participantList.appendChild(li);
            });
        }

        function updateParticipantListWithHands() {
            const items = participantList.querySelectorAll('li');
            items.forEach((item, index) => {
                if (index === 0 && isHandRaised) {
                    item.classList.add('hand-raised');
                    if (!item.querySelector('.hand-icon')) {
                        const handIcon = document.createElement('span');
                        handIcon.className = 'hand-icon';
                        handIcon.textContent = '‚úã';
                        item.appendChild(handIcon);
                    }
                } else if (index === 0) {
                    item.classList.remove('hand-raised');
                    const handIcon = item.querySelector('.hand-icon');
                    if (handIcon) handIcon.remove();
                }
            });
        }

        function start_webrtc() {
            console.log('Starting WebRTC connections');
            for (let peer_id in _peer_list) {
                if (_peer_list[peer_id] === undefined) {
                    createPeerConnection(peer_id);
                    addLocalTracks(peer_id);
                }
            }
        }

        // Audio level detection
        function initAudioLevelDetection() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const audioSource = audioContext.createMediaStreamSource(localStream);
                audioAnalyser = audioContext.createAnalyser();
                audioAnalyser.fftSize = 256;
                audioSource.connect(audioAnalyser);
                
                const dataArray = new Uint8Array(audioAnalyser.frequencyBinCount);
                let lastSpeakingState = false;
                
                function detectSpeaking() {
                    audioAnalyser.getByteFrequencyData(dataArray);
                    const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
                    const isSpeaking = average > 20;
                    
                    if (isSpeaking !== lastSpeakingState) {
                        lastSpeakingState = isSpeaking;
                        
                        // Update local participant card
                        const localCard = document.getElementById('participant-local');
                        if (localCard) {
                            localCard.classList.toggle('speaking', isSpeaking);
                        }
                        
                        // Emit to other participants
                        socket.emit('audio_level', {
                            session_id: sessionId,
                            user_id: myID,
                            level: average,
                            is_speaking: isSpeaking
                        });
                    }
                    
                    requestAnimationFrame(detectSpeaking);
                }
                
                detectSpeaking();
            } catch (error) {
                console.error('Error initializing audio level detection:', error);
            }
        }

        // Socket event handlers
        socket.on('connect', () => {
            console.log('Socket connected');
        });

        socket.on('user-list', (data) => {
            console.log('User list received:', data);
            myID = data['my_id'];
            
            // Add local participant card
            const localCard = document.createElement('div');
            localCard.className = 'participant-card';
            localCard.id = 'participant-local';
            localCard.innerHTML = `
                <div class="participant-avatar color-1">${username.charAt(0).toUpperCase()}</div>
                <div class="participant-name">${username} (You)</div>
                <div class="participant-status">Connected</div>
                <div class="muted-indicator">üîá</div>
                <div class="hand-raised-indicator">‚úã Hand Raised</div>
            `;
            participantsGrid.appendChild(localCard);
            
            if ('list' in data) {
                const recvd_list = data['list'];
                for (let peer_id in recvd_list) {
                    _peer_list[peer_id] = undefined;
                    _peer_names[peer_id] = recvd_list[peer_id];
                    console.log('[USER-LIST] Added peer:', peer_id, 'name:', recvd_list[peer_id]);
                }
                updateParticipantList();
                start_webrtc();
            } else {
                updateParticipantList();
            }
            
            updateParticipantCount();
        });

        socket.on('user-connect', (data) => {
            console.log('New user connected:', data);
            const peer_id = data['sid'];
            const peer_name = data['name'];
            
            if (peer_id !== myID) {
                _peer_list[peer_id] = undefined;
                _peer_names[peer_id] = peer_name;
                updateParticipantList();
            }
        });

        socket.on('user-disconnect', (data) => {
            console.log('User disconnected:', data);
            const peer_id = data['sid'];
            closeConnection(peer_id);
            updateParticipantList();
        });

        socket.on('data', (msg) => {
            console.log('[WEBRTC] Data received:', msg.type, 'from', msg.sender_id);
            switch (msg['type']) {
                case 'offer':
                    handleOfferMsg(msg);
                    break;
                case 'answer':
                    handleAnswerMsg(msg);
                    break;
                case 'new-ice-candidate':
                    handleNewICECandidateMsg(msg);
                    break;
            }
        });

        socket.on('audio_level', (data) => {
            const peer_id = data.user_id;
            const is_speaking = data.is_speaking;
            
            if (peer_id !== myID) {
                const participantCard = document.getElementById(`participant-${peer_id}`);
                if (participantCard) {
                    participantCard.classList.toggle('speaking', is_speaking);
                }
            }
        });

        socket.on('reaction', (data) => {
            const peer_id = data.user_id;
            const emoji = data.emoji;
            
            if (peer_id !== myID) {
                showReaction(peer_id, emoji);
            }
        });

        // Control button event handlers
        micBtn.addEventListener('click', () => {
            isMicMuted = !isMicMuted;
            localStream.getAudioTracks().forEach(track => {
                track.enabled = !isMicMuted;
            });
            micBtn.classList.toggle('muted', isMicMuted);
            micBtn.setAttribute('data-tooltip', isMicMuted ? 'Unmute' : 'Mute');
            
            // Update local participant card
            const localCard = document.getElementById('participant-local');
            if (localCard) {
                const mutedIndicator = localCard.querySelector('.muted-indicator');
                mutedIndicator.classList.toggle('active', isMicMuted);
            }
        });

        handBtn.addEventListener('click', toggleHandRaise);

        reactionBtn.addEventListener('click', () => {
            reactionsMenu.classList.toggle('active');
        });

        document.querySelectorAll('.reaction-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const emoji = btn.getAttribute('data-reaction');
                sendReaction(emoji);
            });
        });

        // Close reactions menu when clicking outside
        document.addEventListener('click', (e) => {
            if (!reactionBtn.contains(e.target) && !reactionsMenu.contains(e.target)) {
                reactionsMenu.classList.remove('active');
            }
        });

        leaveBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to leave the call?')) {
                leaveCall();
            }
        });

        function leaveCall() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            
            for (let peer_id in _peer_list) {
                closeConnection(peer_id);
            }
            
            socket.emit('leave_session', { session_id: sessionId });
            window.close();
        }

        // Initialize the audio call when page loads
        window.addEventListener('load', () => {
            initAudioCall();
        });

        window.addEventListener('beforeunload', () => leaveCall());
    </script>
</body>
</html>