<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Call Debug Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #1e1f22;
            color: #f2f3f5;
            padding: 20px;
        }
        .debug-section {
            background: #2b2d31;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
        }
        button {
            background: #5865f2;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background: #4752c4; }
        video {
            width: 300px;
            height: 200px;
            background: #111;
            border: 2px solid #333;
            border-radius: 8px;
            margin: 10px;
        }
        .log {
            background: #111;
            padding: 10px;
            border-radius: 4px;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }
        .status {
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            font-weight: bold;
        }
        .success { background: #23a55a; }
        .error { background: #da373c; }
        .warning { background: #faa61a; }
    </style>
</head>
<body>
    <h1>Video Call Debug Tool</h1>
    <p>Use this tool to debug video feed issues in your video call system.</p>
    
    <div class="debug-section">
        <h3>1. Media Access Test</h3>
        <button onclick="testMediaAccess()">Test Camera & Microphone</button>
        <button onclick="testVideoOnly()">Test Video Only</button>
        <button onclick="testAudioOnly()">Test Audio Only</button>
        <div id="mediaStatus"></div>
        <video id="testVideo" autoplay muted playsinline></video>
    </div>
    
    <div class="debug-section">
        <h3>2. WebRTC Connection Test</h3>
        <button onclick="testWebRTCConnection()">Test Local WebRTC</button>
        <div id="webrtcStatus"></div>
    </div>
    
    <div class="debug-section">
        <h3>3. Video Call Server Test</h3>
        <button onclick="testVideoCallServer()">Test Video Server Connection</button>
        <div id="serverStatus"></div>
    </div>
    
    <div class="debug-section">
        <h3>4. Debug Information</h3>
        <button onclick="clearLog()">Clear Log</button>
        <button onclick="exportLog()">Export Log</button>
        <div id="debugLog" class="log"></div>
    </div>

    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        let debugLog = '';
        
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}\n`;
            debugLog += logEntry;
            
            const logElement = document.getElementById('debugLog');
            logElement.textContent = debugLog;
            logElement.scrollTop = logElement.scrollHeight;
            
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
        
        function setStatus(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
        }
        
        function clearLog() {
            debugLog = '';
            document.getElementById('debugLog').textContent = '';
        }
        
        function exportLog() {
            const blob = new Blob([debugLog], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `video-debug-${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        async function testMediaAccess() {
            log('Testing full media access (video + audio)...');
            setStatus('mediaStatus', 'Testing...', 'warning');
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: { ideal: 1280 }, 
                        height: { ideal: 720 },
                        facingMode: 'user'
                    },
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                const videoTracks = stream.getVideoTracks();
                const audioTracks = stream.getAudioTracks();
                
                log(`SUCCESS: Got ${videoTracks.length} video tracks, ${audioTracks.length} audio tracks`);
                
                // Set video source
                const testVideo = document.getElementById('testVideo');
                testVideo.srcObject = stream;
                
                // Log track details
                videoTracks.forEach((track, i) => {
                    log(`Video Track ${i}: ${track.label}, enabled: ${track.enabled}, readyState: ${track.readyState}`);
                });
                audioTracks.forEach((track, i) => {
                    log(`Audio Track ${i}: ${track.label}, enabled: ${track.enabled}, readyState: ${track.readyState}`);
                });
                
                setStatus('mediaStatus', `✓ Success: ${videoTracks.length} video, ${audioTracks.length} audio tracks`, 'success');
                
                // Test video dimensions after metadata loads
                testVideo.onloadedmetadata = () => {
                    log(`Video dimensions: ${testVideo.videoWidth}x${testVideo.videoHeight}`);
                    if (testVideo.videoWidth === 0 || testVideo.videoHeight === 0) {
                        log('WARNING: Video has no dimensions - might indicate a problem', 'warning');
                    }
                };
                
            } catch (error) {
                log(`ERROR: Media access failed - ${error.name}: ${error.message}`);
                setStatus('mediaStatus', `✗ Failed: ${error.name} - ${error.message}`, 'error');
            }
        }
        
        async function testVideoOnly() {
            log('Testing video-only access...');
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: { ideal: 1280 }, 
                        height: { ideal: 720 }
                    }
                });
                
                log(`SUCCESS: Got video-only stream with ${stream.getVideoTracks().length} tracks`);
                document.getElementById('testVideo').srcObject = stream;
                
            } catch (error) {
                log(`ERROR: Video-only access failed - ${error.name}: ${error.message}`);
            }
        }
        
        async function testAudioOnly() {
            log('Testing audio-only access...');
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                log(`SUCCESS: Got audio-only stream with ${stream.getAudioTracks().length} tracks`);
                
            } catch (error) {
                log(`ERROR: Audio-only access failed - ${error.name}: ${error.message}`);
            }
        }
        
        async function testWebRTCConnection() {
            log('Testing WebRTC peer connection...');
            setStatus('webrtcStatus', 'Testing...', 'warning');
            
            try {
                const pc1 = new RTCPeerConnection({
                    iceServers: [], // Local network only
                    bundlePolicy: 'balanced',
                    rtcpMuxPolicy: 'require'
                });
                
                const pc2 = new RTCPeerConnection({
                    iceServers: [], // Local network only
                    bundlePolicy: 'balanced',
                    rtcpMuxPolicy: 'require'
                });
                
                let pc1Candidates = 0;
                let pc2Candidates = 0;
                
                pc1.onicecandidate = (event) => {
                    if (event.candidate) {
                        pc1Candidates++;
                        log(`PC1 ICE candidate ${pc1Candidates}: ${event.candidate.candidate.substring(0, 50)}...`);
                        pc2.addIceCandidate(event.candidate);
                    }
                };
                
                pc2.onicecandidate = (event) => {
                    if (event.candidate) {
                        pc2Candidates++;
                        log(`PC2 ICE candidate ${pc2Candidates}: ${event.candidate.candidate.substring(0, 50)}...`);
                        pc1.addIceCandidate(event.candidate);
                    }
                };
                
                pc1.onconnectionstatechange = () => {
                    log(`PC1 connection state: ${pc1.connectionState}`);
                };
                
                pc2.onconnectionstatechange = () => {
                    log(`PC2 connection state: ${pc2.connectionState}`);
                };
                
                // Get media stream for testing
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                
                // Add tracks to PC1
                stream.getTracks().forEach(track => {
                    pc1.addTrack(track, stream);
                    log(`Added ${track.kind} track to PC1`);
                });
                
                // Set up PC2 to receive tracks
                pc2.ontrack = (event) => {
                    log(`PC2 received ${event.track.kind} track: enabled=${event.track.enabled}, readyState=${event.track.readyState}`);
                };
                
                // Create offer
                const offer = await pc1.createOffer();
                await pc1.setLocalDescription(offer);
                await pc2.setRemoteDescription(offer);
                log('Offer created and set');
                
                // Create answer
                const answer = await pc2.createAnswer();
                await pc2.setLocalDescription(answer);
                await pc1.setRemoteDescription(answer);
                log('Answer created and set');
                
                // Wait for connection
                setTimeout(() => {
                    if (pc1.connectionState === 'connected' && pc2.connectionState === 'connected') {
                        log('SUCCESS: WebRTC connection established');
                        setStatus('webrtcStatus', '✓ Success: WebRTC connection works', 'success');
                    } else {
                        log(`WARNING: Connection states - PC1: ${pc1.connectionState}, PC2: ${pc2.connectionState}`);
                        setStatus('webrtcStatus', `⚠ Partial: PC1=${pc1.connectionState}, PC2=${pc2.connectionState}`, 'warning');
                    }
                    
                    // Cleanup
                    pc1.close();
                    pc2.close();
                    stream.getTracks().forEach(track => track.stop());
                }, 3000);
                
            } catch (error) {
                log(`ERROR: WebRTC test failed - ${error.message}`);
                setStatus('webrtcStatus', `✗ Failed: ${error.message}`, 'error');
            }
        }
        
        function testVideoCallServer() {
            log('Testing video call server connection...');
            setStatus('serverStatus', 'Testing...', 'warning');
            
            const socket = io('https://10.200.14.94:5000', { 
                autoConnect: false,
                timeout: 5000
            });
            
            socket.on('connect', () => {
                log('SUCCESS: Connected to video call server');
                setStatus('serverStatus', '✓ Success: Server connection works', 'success');
                
                // Test joining a session
                socket.emit('join_session', { 
                    session_id: 'debug-test', 
                    username: 'DebugUser' 
                });
            });
            
            socket.on('user-list', (data) => {
                log(`Received user list: ${JSON.stringify(data)}`);
            });
            
            socket.on('connect_error', (error) => {
                log(`ERROR: Server connection failed - ${error.message}`);
                setStatus('serverStatus', `✗ Failed: ${error.message}`, 'error');
            });
            
            socket.on('disconnect', (reason) => {
                log(`Server disconnected: ${reason}`);
            });
            
            socket.connect();
            
            // Timeout after 10 seconds
            setTimeout(() => {
                if (!socket.connected) {
                    log('ERROR: Server connection timeout');
                    setStatus('serverStatus', '✗ Failed: Connection timeout', 'error');
                }
                socket.disconnect();
            }, 10000);
        }
        
        // Auto-run basic checks on load
        window.addEventListener('load', () => {
            log('Video Call Debug Tool loaded');
            log('Browser: ' + navigator.userAgent);
            log('WebRTC support: ' + (!!window.RTCPeerConnection));
            log('getUserMedia support: ' + (!!navigator.mediaDevices?.getUserMedia));
            log('');
            log('Click the buttons above to run specific tests');
            log('Use Ctrl+Shift+V in the video call to run debugVideoStates()');
        });
    </script>
</body>
</html>